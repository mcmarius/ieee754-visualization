// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split('/');
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"fraction.js": {
		":mainpath:": "fraction",
		"fraction.js": function (exports, module, require) {
			/**
			 * @license Fraction.js v4.1.1 23/05/2021
			 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
			 *
			 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
			 * Dual licensed under the MIT or GPL Version 2 licenses.
			 **/


			/**
			 *
			 * This class offers the possibility to calculate fractions.
			 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
			 *
			 * Array/Object form
			 * [ 0 => <nominator>, 1 => <denominator> ]
			 * [ n => <nominator>, d => <denominator> ]
			 *
			 * Integer form
			 * - Single integer value
			 *
			 * Double form
			 * - Single double value
			 *
			 * String form
			 * 123.456 - a simple double
			 * 123/456 - a string fraction
			 * 123.'456' - a double with repeating decimal places
			 * 123.(456) - synonym
			 * 123.45'6' - a double with repeating last place
			 * 123.45(6) - synonym
			 *
			 * Example:
			 *
			 * var f = new Fraction("9.4'31'");
			 * f.mul([-4, 3]).div(4.9);
			 *
			 */

			(function(root) {

			  "use strict";

			  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
			  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
			  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
			  var MAX_CYCLE_LEN = 2000;

			  // Parsed data to avoid calling "new" all the time
			  var P = {
			    "s": 1,
			    "n": 0,
			    "d": 1
			  };

			  function createError(name) {

			    function errorConstructor() {
			      var temp = Error.apply(this, arguments);
			      temp['name'] = this['name'] = name;
			      this['stack'] = temp['stack'];
			      this['message'] = temp['message'];
			    }

			    /**
			     * Error constructor
			     *
			     * @constructor
			     */
			    function IntermediateInheritor() { }
			    IntermediateInheritor.prototype = Error.prototype;
			    errorConstructor.prototype = new IntermediateInheritor();

			    return errorConstructor;
			  }

			  var DivisionByZero = Fraction['DivisionByZero'] = createError('DivisionByZero');
			  var InvalidParameter = Fraction['InvalidParameter'] = createError('InvalidParameter');

			  function assign(n, s) {

			    if (isNaN(n = parseInt(n, 10))) {
			      throwInvalidParam();
			    }
			    return n * s;
			  }

			  function throwInvalidParam() {
			    throw new InvalidParameter();
			  }

			  function factorize(num) {

			    var factors = {};

			    var n = num;
			    var i = 2;
			    var s = 4;

			    while (s <= n) {

			      while (n % i === 0) {
			        n /= i;
			        factors[i] = (factors[i] || 0) + 1;
			      }
			      s += 1 + 2 * i++;
			    }

			    if (n !== num) {
			      if (n > 1)
			      factors[n] = (factors[n] || 0) + 1;
			    } else {
			      factors[num] = (factors[num] || 0) + 1;
			    }
			    return factors;
			  }

			  var parse = function(p1, p2) {

			    var n = 0, d = 1, s = 1;
			    var v = 0, w = 0, x = 0, y = 1, z = 1;

			    var A = 0, B = 1;
			    var C = 1, D = 1;

			    var N = 10000000;
			    var M;

			    if (p1 === undefined || p1 === null) {
			      /* void */
			    } else if (p2 !== undefined) {
			      n = p1;
			      d = p2;
			      s = n * d;
			    } else
			      switch (typeof p1) {

			        case "object":
			          {
			            if ("d" in p1 && "n" in p1) {
			              n = p1["n"];
			              d = p1["d"];
			              if ("s" in p1)
			                n *= p1["s"];
			            } else if (0 in p1) {
			              n = p1[0];
			              if (1 in p1)
			                d = p1[1];
			            } else {
			              throwInvalidParam();
			            }
			            s = n * d;
			            break;
			          }
			        case "number":
			          {
			            if (p1 < 0) {
			              s = p1;
			              p1 = -p1;
			            }

			            if (p1 % 1 === 0) {
			              n = p1;
			            } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow

			              if (p1 >= 1) {
			                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
			                p1 /= z;
			              }

			              // Using Farey Sequences
			              // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

			              while (B <= N && D <= N) {
			                M = (A + C) / (B + D);

			                if (p1 === M) {
			                  if (B + D <= N) {
			                    n = A + C;
			                    d = B + D;
			                  } else if (D > B) {
			                    n = C;
			                    d = D;
			                  } else {
			                    n = A;
			                    d = B;
			                  }
			                  break;

			                } else {

			                  if (p1 > M) {
			                    A += C;
			                    B += D;
			                  } else {
			                    C += A;
			                    D += B;
			                  }

			                  if (B > N) {
			                    n = C;
			                    d = D;
			                  } else {
			                    n = A;
			                    d = B;
			                  }
			                }
			              }
			              n *= z;
			            } else if (isNaN(p1) || isNaN(p2)) {
			              d = n = NaN;
			            }
			            break;
			          }
			        case "string":
			          {
			            B = p1.match(/\d+|./g);

			            if (B === null)
			              throwInvalidParam();

			            if (B[A] === '-') {// Check for minus sign at the beginning
			              s = -1;
			              A++;
			            } else if (B[A] === '+') {// Check for plus sign at the beginning
			              A++;
			            }

			            if (B.length === A + 1) { // Check if it's just a simple number "1234"
			              w = assign(B[A++], s);
			            } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number

			              if (B[A] !== '.') { // Handle 0.5 and .5
			                v = assign(B[A++], s);
			              }
			              A++;

			              // Check for decimal places
			              if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
			                w = assign(B[A], s);
			                y = Math.pow(10, B[A].length);
			                A++;
			              }

			              // Check for repeating places
			              if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
			                x = assign(B[A + 1], s);
			                z = Math.pow(10, B[A + 1].length) - 1;
			                A += 3;
			              }

			            } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction "123/456" or "123:456"
			              w = assign(B[A], s);
			              y = assign(B[A + 2], 1);
			              A += 3;
			            } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction "123 1/2"
			              v = assign(B[A], s);
			              w = assign(B[A + 2], s);
			              y = assign(B[A + 4], 1);
			              A += 5;
			            }

			            if (B.length <= A) { // Check for more tokens on the stack
			              d = y * z;
			              s = /* void */
			              n = x + d * v + z * w;
			              break;
			            }

			            /* Fall through on error */
			          }
			        default:
			          throwInvalidParam();
			      }

			    if (d === 0) {
			      throw new DivisionByZero();
			    }

			    P["s"] = s < 0 ? -1 : 1;
			    P["n"] = Math.abs(n);
			    P["d"] = Math.abs(d);
			  };

			  function modpow(b, e, m) {

			    var r = 1;
			    for (; e > 0; b = (b * b) % m, e >>= 1) {

			      if (e & 1) {
			        r = (r * b) % m;
			      }
			    }
			    return r;
			  }


			  function cycleLen(n, d) {

			    for (; d % 2 === 0;
			      d /= 2) {
			    }

			    for (; d % 5 === 0;
			      d /= 5) {
			    }

			    if (d === 1) // Catch non-cyclic numbers
			      return 0;

			    // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
			    // 10^(d-1) % d == 1
			    // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
			    // as we want to translate the numbers to strings.

			    var rem = 10 % d;
			    var t = 1;

			    for (; rem !== 1; t++) {
			      rem = rem * 10 % d;

			      if (t > MAX_CYCLE_LEN)
			        return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
			    }
			    return t;
			  }


			  function cycleStart(n, d, len) {

			    var rem1 = 1;
			    var rem2 = modpow(10, len, d);

			    for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)
			      // Solve 10^s == 10^(s+t) (mod d)

			      if (rem1 === rem2)
			        return t;

			      rem1 = rem1 * 10 % d;
			      rem2 = rem2 * 10 % d;
			    }
			    return 0;
			  }

			  function gcd(a, b) {

			    if (!a)
			      return b;
			    if (!b)
			      return a;

			    while (1) {
			      a %= b;
			      if (!a)
			        return b;
			      b %= a;
			      if (!b)
			        return a;
			    }
			  };

			  /**
			   * Module constructor
			   *
			   * @constructor
			   * @param {number|Fraction=} a
			   * @param {number=} b
			   */
			  function Fraction(a, b) {

			    if (!(this instanceof Fraction)) {
			      return new Fraction(a, b);
			    }

			    parse(a, b);

			    if (Fraction['REDUCE']) {
			      a = gcd(P["d"], P["n"]); // Abuse a
			    } else {
			      a = 1;
			    }

			    this["s"] = P["s"];
			    this["n"] = P["n"] / a;
			    this["d"] = P["d"] / a;
			  }

			  /**
			   * Boolean global variable to be able to disable automatic reduction of the fraction
			   *
			   */
			  Fraction['REDUCE'] = 1;

			  Fraction.prototype = {

			    "s": 1,
			    "n": 0,
			    "d": 1,

			    /**
			     * Calculates the absolute value
			     *
			     * Ex: new Fraction(-4).abs() => 4
			     **/
			    "abs": function() {

			      return new Fraction(this["n"], this["d"]);
			    },

			    /**
			     * Inverts the sign of the current fraction
			     *
			     * Ex: new Fraction(-4).neg() => 4
			     **/
			    "neg": function() {

			      return new Fraction(-this["s"] * this["n"], this["d"]);
			    },

			    /**
			     * Adds two rational numbers
			     *
			     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
			     **/
			    "add": function(a, b) {

			      parse(a, b);
			      return new Fraction(
			        this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
			        this["d"] * P["d"]
			      );
			    },

			    /**
			     * Subtracts two rational numbers
			     *
			     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
			     **/
			    "sub": function(a, b) {

			      parse(a, b);
			      return new Fraction(
			        this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
			        this["d"] * P["d"]
			      );
			    },

			    /**
			     * Multiplies two rational numbers
			     *
			     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
			     **/
			    "mul": function(a, b) {

			      parse(a, b);
			      return new Fraction(
			        this["s"] * P["s"] * this["n"] * P["n"],
			        this["d"] * P["d"]
			      );
			    },

			    /**
			     * Divides two rational numbers
			     *
			     * Ex: new Fraction("-17.(345)").inverse().div(3)
			     **/
			    "div": function(a, b) {

			      parse(a, b);
			      return new Fraction(
			        this["s"] * P["s"] * this["n"] * P["d"],
			        this["d"] * P["n"]
			      );
			    },

			    /**
			     * Clones the actual object
			     *
			     * Ex: new Fraction("-17.(345)").clone()
			     **/
			    "clone": function() {
			      return new Fraction(this);
			    },

			    /**
			     * Calculates the modulo of two rational numbers - a more precise fmod
			     *
			     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
			     **/
			    "mod": function(a, b) {

			      if (isNaN(this['n']) || isNaN(this['d'])) {
			        return new Fraction(NaN);
			      }

			      if (a === undefined) {
			        return new Fraction(this["s"] * this["n"] % this["d"], 1);
			      }

			      parse(a, b);
			      if (0 === P["n"] && 0 === this["d"]) {
			        Fraction(0, 0); // Throw DivisionByZero
			      }

			      /*
			       * First silly attempt, kinda slow
			       *
			       return that["sub"]({
			       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
			       "d": num["d"],
			       "s": this["s"]
			       });*/

			      /*
			       * New attempt: a1 / b1 = a2 / b2 * q + r
			       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
			       * => (b2 * a1 % a2 * b1) / (b1 * b2)
			       */
			      return new Fraction(
			        this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
			        P["d"] * this["d"]
			      );
			    },

			    /**
			     * Calculates the fractional gcd of two rational numbers
			     *
			     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
			     */
			    "gcd": function(a, b) {

			      parse(a, b);

			      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

			      return new Fraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
			    },

			    /**
			     * Calculates the fractional lcm of two rational numbers
			     *
			     * Ex: new Fraction(5,8).lcm(3,7) => 15
			     */
			    "lcm": function(a, b) {

			      parse(a, b);

			      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

			      if (P["n"] === 0 && this["n"] === 0) {
			        return new Fraction;
			      }
			      return new Fraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
			    },

			    /**
			     * Calculates the ceil of a rational number
			     *
			     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
			     **/
			    "ceil": function(places) {

			      places = Math.pow(10, places || 0);

			      if (isNaN(this["n"]) || isNaN(this["d"])) {
			        return new Fraction(NaN);
			      }
			      return new Fraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
			    },

			    /**
			     * Calculates the floor of a rational number
			     *
			     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
			     **/
			    "floor": function(places) {

			      places = Math.pow(10, places || 0);

			      if (isNaN(this["n"]) || isNaN(this["d"])) {
			        return new Fraction(NaN);
			      }
			      return new Fraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
			    },

			    /**
			     * Rounds a rational numbers
			     *
			     * Ex: new Fraction('4.(3)').round() => (4 / 1)
			     **/
			    "round": function(places) {

			      places = Math.pow(10, places || 0);

			      if (isNaN(this["n"]) || isNaN(this["d"])) {
			        return new Fraction(NaN);
			      }
			      return new Fraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
			    },

			    /**
			     * Gets the inverse of the fraction, means numerator and denominator are exchanged
			     *
			     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
			     **/
			    "inverse": function() {

			      return new Fraction(this["s"] * this["d"], this["n"]);
			    },

			    /**
			     * Calculates the fraction to some rational exponent, if possible
			     *
			     * Ex: new Fraction(-1,2).pow(-3) => -8
			     */
			    "pow": function(a, b) {

			      parse(a, b);

			      // Trivial case when exp is an integer

			      if (P['d'] === 1) {

			        if (P['s'] < 0) {
			          return new Fraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
			        } else {
			          return new Fraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
			        }
			      }

			      // Negative roots become complex
			      //     (-a/b)^(c/d) = x
			      // <=> (-1)^(c/d) * (a/b)^(c/d) = x
			      // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180Â°
			      // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
			      // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
			      if (this['s'] < 0) return null;

			      // Now prime factor n and d
			      var N = factorize(this['n']);
			      var D = factorize(this['d']);

			      // Exponentiate and take root for n and d individually
			      var n = 1;
			      var d = 1;
			      for (var k in N) {
			        if (k === '1') continue;
			        if (k === '0') {
			          n = 0;
			          break;
			        }
			        N[k]*= P['n'];

			        if (N[k] % P['d'] === 0) {
			          N[k]/= P['d'];
			        } else return null;
			        n*= Math.pow(k, N[k]);
			      }

			      for (var k in D) {
			        if (k === '1') continue;
			        D[k]*= P['n'];

			        if (D[k] % P['d'] === 0) {
			          D[k]/= P['d'];
			        } else return null;
			        d*= Math.pow(k, D[k]);
			      }

			      if (P['s'] < 0) {
			        return new Fraction(d, n);
			      }
			      return new Fraction(n, d);
			    },

			    /**
			     * Check if two rational numbers are the same
			     *
			     * Ex: new Fraction(19.6).equals([98, 5]);
			     **/
			    "equals": function(a, b) {

			      parse(a, b);
			      return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
			    },

			    /**
			     * Check if two rational numbers are the same
			     *
			     * Ex: new Fraction(19.6).equals([98, 5]);
			     **/
			    "compare": function(a, b) {

			      parse(a, b);
			      var t = (this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"]);
			      return (0 < t) - (t < 0);
			    },

			    "simplify": function(eps) {

			      // First naive implementation, needs improvement

			      if (isNaN(this['n']) || isNaN(this['d'])) {
			        return this;
			      }

			      var cont = this['abs']()['toContinued']();

			      eps = eps || 0.001;

			      function rec(a) {
			        if (a.length === 1)
			          return new Fraction(a[0]);
			        return rec(a.slice(1))['inverse']()['add'](a[0]);
			      }

			      for (var i = 0; i < cont.length; i++) {
			        var tmp = rec(cont.slice(0, i + 1));
			        if (tmp['sub'](this['abs']())['abs']().valueOf() < eps) {
			          return tmp['mul'](this['s']);
			        }
			      }
			      return this;
			    },

			    /**
			     * Check if two rational numbers are divisible
			     *
			     * Ex: new Fraction(19.6).divisible(1.5);
			     */
			    "divisible": function(a, b) {

			      parse(a, b);
			      return !(!(P["n"] * this["d"]) || ((this["n"] * P["d"]) % (P["n"] * this["d"])));
			    },

			    /**
			     * Returns a decimal representation of the fraction
			     *
			     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
			     **/
			    'valueOf': function() {

			      return this["s"] * this["n"] / this["d"];
			    },

			    /**
			     * Returns a string-fraction representation of a Fraction object
			     *
			     * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
			     **/
			    'toFraction': function(excludeWhole) {

			      var whole, str = "";
			      var n = this["n"];
			      var d = this["d"];
			      if (this["s"] < 0) {
			        str += '-';
			      }

			      if (d === 1) {
			        str += n;
			      } else {

			        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
			          str += whole;
			          str += " ";
			          n %= d;
			        }

			        str += n;
			        str += '/';
			        str += d;
			      }
			      return str;
			    },

			    /**
			     * Returns a latex representation of a Fraction object
			     *
			     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
			     **/
			    'toLatex': function(excludeWhole) {

			      var whole, str = "";
			      var n = this["n"];
			      var d = this["d"];
			      if (this["s"] < 0) {
			        str += '-';
			      }

			      if (d === 1) {
			        str += n;
			      } else {

			        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
			          str += whole;
			          n %= d;
			        }

			        str += "\\frac{";
			        str += n;
			        str += '}{';
			        str += d;
			        str += '}';
			      }
			      return str;
			    },

			    /**
			     * Returns an array of continued fraction elements
			     *
			     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
			     */
			    'toContinued': function() {

			      var t;
			      var a = this['n'];
			      var b = this['d'];
			      var res = [];

			      if (isNaN(a) || isNaN(b)) {
			        return res;
			      }

			      do {
			        res.push(Math.floor(a / b));
			        t = a % b;
			        a = b;
			        b = t;
			      } while (a !== 1);

			      return res;
			    },

			    /**
			     * Creates a string representation of a fraction with all digits
			     *
			     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
			     **/
			    'toString': function(dec) {

			      var g;
			      var N = this["n"];
			      var D = this["d"];

			      if (isNaN(N) || isNaN(D)) {
			        return "NaN";
			      }

			      if (!Fraction['REDUCE']) {
			        g = gcd(N, D);
			        N /= g;
			        D /= g;
			      }

			      dec = dec || 15; // 15 = decimal places when no repetation

			      var cycLen = cycleLen(N, D); // Cycle length
			      var cycOff = cycleStart(N, D, cycLen); // Cycle start

			      var str = this['s'] === -1 ? "-" : "";

			      str += N / D | 0;

			      N %= D;
			      N *= 10;

			      if (N)
			        str += ".";

			      if (cycLen) {

			        for (var i = cycOff; i--;) {
			          str += N / D | 0;
			          N %= D;
			          N *= 10;
			        }
			        str += "(";
			        for (var i = cycLen; i--;) {
			          str += N / D | 0;
			          N %= D;
			          N *= 10;
			        }
			        str += ")";
			      } else {
			        for (var i = dec; N && i--;) {
			          str += N / D | 0;
			          N %= D;
			          N *= 10;
			        }
			      }
			      return str;
			    }
			  };

			  if (typeof define === "function" && define["amd"]) {
			    define([], function() {
			      return Fraction;
			    });
			  } else if (typeof exports === "object") {
			    Object.defineProperty(Fraction, "__esModule", { 'value': true });
			    Fraction['default'] = Fraction;
			    Fraction['Fraction'] = Fraction;
			    module['exports'] = Fraction;
			  } else {
			    root['Fraction'] = Fraction;
			  }

			})(this);
		}
	},
	"ieee754-visualization": {
		"node_modules": {
			"@petamoriken": {
				"float16": {
					"index.js": function (exports, module, require) {
						/* eslint-env node */

						"use strict";

						Object.defineProperty(exports, "__esModule", { value: true });

						const { setFloat16, getFloat16 } = require("./lib/DataView.js");
						const { Float16Array, isFloat16Array } = require("./lib/Float16Array.js");
						const { hfround } = require("./lib/hfround.js");

						Object.defineProperty(exports, "hfround", {
						  enumerable: true,
						  get: function () {
						    return hfround;
						  },
						});
						Object.defineProperty(exports, "Float16Array", {
						  enumerable: true,
						  get: function () {
						    return Float16Array;
						  },
						});
						Object.defineProperty(exports, "isFloat16Array", {
						  enumerable: true,
						  get: function () {
						    return isFloat16Array;
						  },
						});
						Object.defineProperty(exports, "getFloat16", {
						  enumerable: true,
						  get: function () {
						    return getFloat16;
						  },
						});
						Object.defineProperty(exports, "setFloat16", {
						  enumerable: true,
						  get: function () {
						    return setFloat16;
						  },
						});
					},
					"lib": {
						"DataView.js": function (exports, module, require) {
							"use strict";

							Object.defineProperty(exports, "__esModule", {
							  value: true
							});
							exports.getFloat16 = getFloat16;
							exports.setFloat16 = setFloat16;

							var _is = require("./helper/is.js");

							var _lib = require("./helper/lib.js");

							/**
							 * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView.
							 * @param {DataView} dataView
							 * @param {number} byteOffset
							 * @param {[boolean]} opts
							 * @returns {number}
							 */
							function getFloat16(dataView, byteOffset, ...opts) {
							  if (!(0, _is.isDataView)(dataView)) {
							    throw new TypeError("First argument to getFloat16 function must be a DataView");
							  }

							  return (0, _lib.convertToNumber)(dataView.getUint16(byteOffset, ...opts));
							}
							/**
							 * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView.
							 * @param {DataView} dataView
							 * @param {number} byteOffset
							 * @param {number} value
							 * @param {[boolean]} opts
							 */


							function setFloat16(dataView, byteOffset, value, ...opts) {
							  if (!(0, _is.isDataView)(dataView)) {
							    throw new TypeError("First argument to setFloat16 function must be a DataView");
							  }

							  dataView.setUint16(byteOffset, (0, _lib.roundToFloat16Bits)(value), ...opts);
							}
						},
						"Float16Array.js": function (exports, module, require) {
							"use strict";

							Object.defineProperty(exports, "__esModule", {
							  value: true
							});
							exports.isFloat16Array = isFloat16Array;
							exports.Float16Array = void 0;

							var _arrayIterator = require("./helper/arrayIterator.js");

							var _is = require("./helper/is.js");

							var _lib = require("./helper/lib.js");

							var _private = require("./helper/private.js");

							var _spec = require("./helper/spec.js");

							const brand = Symbol.for("__Float16Array__");

							const _ = (0, _private.createPrivateStorage)();
							/**
							 * @param {unknown} target
							 * @returns {boolean}
							 */


							function hasFloat16ArrayBrand(target) {
							  if (!(0, _is.isObjectLike)(target)) {
							    return false;
							  }

							  const constructor = target.constructor;

							  if (constructor === undefined) {
							    return false;
							  }

							  if (!(0, _is.isObject)(constructor)) {
							    throw TypeError("constructor is not a object");
							  }

							  return Reflect.has(constructor, brand);
							}
							/**
							 * @param {unknown} target
							 * @returns {boolean}
							 */


							function isFloat16Array(target) {
							  return hasFloat16ArrayBrand(target) && !(0, _is.isTypedArray)(target);
							}
							/**
							 * @param {unknown} target
							 * @returns {boolean}
							 */


							function isFloat16BitsArray(target) {
							  return hasFloat16ArrayBrand(target) && (0, _is.isUint16Array)(target);
							}
							/**
							 * @param {unknown} target
							 * @throws {TypeError}
							 */


							function assertFloat16BitsArray(target) {
							  if (!isFloat16BitsArray(target)) {
							    throw new TypeError("This is not a Float16Array");
							  }
							}
							/**
							 * peel off Proxy
							 * @param {Float16Array} float16
							 * @return {Float16Array}
							 */


							function getFloat16BitsArrayFromFloat16Array(float16) {
							  let target = _(float16).target; // from another realm


							  if (target === undefined) {
							    const clone = new Float16Array(float16.buffer, float16.byteOffset, float16.length);
							    target = _(clone).target;
							  }

							  return target;
							}
							/**
							 * @param {unknown} target
							 * @returns {boolean}
							 */


							function isDefaultFloat16ArrayMethods(target) {
							  return typeof target === "function" && defaultFloat16ArrayMethods.has(target);
							}
							/**
							 * @param {Float16Array} float16bitsArray
							 * @return {number[]}
							 */


							function copyToArray(float16bitsArray) {
							  const length = float16bitsArray.length;
							  const array = [];

							  for (let i = 0; i < length; ++i) {
							    array.push((0, _lib.convertToNumber)(float16bitsArray[i]));
							  }

							  return array;
							}
							/** @type {ProxyHandler<Function>} */


							const applyHandler = Object.freeze({
							  apply(func, thisArg, args) {
							    // peel off Proxy
							    if (isFloat16Array(thisArg)) {
							      const target = getFloat16BitsArrayFromFloat16Array(thisArg);
							      return Reflect.apply(func, target, args);
							    }

							    return Reflect.apply(func, thisArg, args);
							  }

							});
							/** @type {ProxyHandler<Float16Array>} */

							const handler = Object.freeze({
							  get(target, key) {
							    if ((0, _is.isCanonicalIntegerIndexString)(key)) {
							      const raw = Reflect.get(target, key);
							      return raw !== undefined ? (0, _lib.convertToNumber)(raw) : undefined;
							    } else {
							      const ret = Reflect.get(target, key);

							      if (!isDefaultFloat16ArrayMethods(ret)) {
							        return ret;
							      } // TypedArray methods can't be called by Proxy Object


							      let proxy = _(ret).proxy;

							      if (proxy === undefined) {
							        proxy = _(ret).proxy = new Proxy(ret, applyHandler);
							      }

							      return proxy;
							    }
							  },

							  set(target, key, value) {
							    if ((0, _is.isCanonicalIntegerIndexString)(key)) {
							      return Reflect.set(target, key, (0, _lib.roundToFloat16Bits)(value));
							    } else {
							      return Reflect.set(target, key, value);
							    }
							  }

							});
							const hasOwnProperty = Object.prototype.hasOwnProperty;
							/**
							 * limitation: see README.md for details
							 */

							class Float16Array extends Uint16Array {
							  /**
							   * @see https://tc39.es/ecma262/#sec-typedarray
							   */
							  constructor(input, byteOffset, length) {
							    // input Float16Array
							    if (isFloat16Array(input)) {
							      // peel off Proxy
							      super(getFloat16BitsArrayFromFloat16Array(input)); // object without ArrayBuffer
							    } else if ((0, _is.isObject)(input) && !(0, _is.isArrayBuffer)(input)) {
							      let list;
							      let length; // TypedArray

							      if ((0, _is.isTypedArray)(input)) {
							        list = input;
							        length = input.length;
							        const buffer = input.buffer;
							        /** @type {ArrayBufferConstructor} */

							        const BufferConstructor = !(0, _is.isSharedArrayBuffer)(buffer) ? (0, _spec.SpeciesConstructor)(buffer, ArrayBuffer) : ArrayBuffer;
							        const data = new BufferConstructor(length * Float16Array.BYTES_PER_ELEMENT);
							        super(data); // Iterable (Array)
							      } else if ((0, _is.isIterable)(input)) {
							        list = [...input];
							        length = list.length;
							        super(length); // ArrayLike
							      } else {
							        list = input;
							        length = (0, _spec.LengthOfArrayLike)(input);
							        super(length);
							      } // set values


							      for (let i = 0; i < length; ++i) {
							        // super (Uint16Array)
							        this[i] = (0, _lib.roundToFloat16Bits)(list[i]);
							      } // primitive, ArrayBuffer

							    } else {
							      switch (arguments.length) {
							        case 0:
							          super();
							          break;

							        case 1:
							          super(input);
							          break;

							        case 2:
							          super(input, byteOffset);
							          break;

							        case 3:
							          super(input, byteOffset, length);
							          break;

							        default:
							          super(...arguments);
							      }
							    }

							    const proxy = new Proxy(this, handler); // proxy private storage

							    _(proxy).target = this; // this private storage

							    _(this).proxy = proxy;
							    return proxy;
							  }
							  /**
							   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.from
							   */


							  static from(src, ...opts) {
							    // for optimization
							    if (isFloat16Array(src) && opts.length === 0) {
							      const uint16 = new Uint16Array(src.buffer, src.byteOffset, src.length);
							      return new Float16Array(uint16.slice().buffer);
							    }

							    if (opts.length === 0) {
							      return new Float16Array(Uint16Array.from(src, _lib.roundToFloat16Bits).buffer);
							    }

							    const mapFunc = opts[0];
							    const thisArg = opts[1];
							    return new Float16Array(Uint16Array.from(src, function (val, ...args) {
							      return (0, _lib.roundToFloat16Bits)(mapFunc.call(this, val, ...args));
							    }, thisArg).buffer);
							  }
							  /**
							   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.of
							   */


							  static of(...items) {
							    const length = items.length;
							    const proxy = new Float16Array(length);
							    const float16bitsArray = getFloat16BitsArrayFromFloat16Array(proxy);

							    for (let i = 0; i < length; ++i) {
							      float16bitsArray[i] = (0, _lib.roundToFloat16Bits)(items[i]);
							    }

							    return proxy;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
							   */


							  keys() {
							    assertFloat16BitsArray(this);
							    return super.keys();
							  }
							  /**
							   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
							   */


							  values() {
							    assertFloat16BitsArray(this);
							    const arrayIterator = super.values();
							    return (0, _arrayIterator.wrapInArrayIterator)(function* () {
							      for (const val of arrayIterator) {
							        yield (0, _lib.convertToNumber)(val);
							      }
							    }());
							  }
							  /**
							   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
							   */


							  entries() {
							    assertFloat16BitsArray(this);
							    const arrayIterator = super.entries();
							    return (0, _arrayIterator.wrapInArrayIterator)(function* () {
							      for (const [i, val] of arrayIterator) {
							        yield [i, (0, _lib.convertToNumber)(val)];
							      }
							    }());
							  }
							  /**
							   * @see https://tc39.es/proposal-relative-indexing-method/#sec-%typedarray%.prototype.at
							   */


							  at(index) {
							    assertFloat16BitsArray(this);
							    const length = this.length;
							    const relativeIndex = (0, _spec.ToIntegerOrInfinity)(index);
							    const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;

							    if (k < 0 || k >= length) {
							      return;
							    }

							    return (0, _lib.convertToNumber)(this[k]);
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
							   */


							  map(callback, ...opts) {
							    assertFloat16BitsArray(this);
							    const thisArg = opts[0];
							    const length = this.length;
							    const Constructor = (0, _spec.SpeciesConstructor)(this, Float16Array); // for optimization

							    if (Constructor === Float16Array) {
							      const proxy = new Float16Array(length);
							      const float16bitsArray = getFloat16BitsArrayFromFloat16Array(proxy);

							      for (let i = 0; i < length; ++i) {
							        const val = (0, _lib.convertToNumber)(this[i]);
							        float16bitsArray[i] = (0, _lib.roundToFloat16Bits)(callback.call(thisArg, val, i, _(this).proxy));
							      }

							      return proxy;
							    }

							    const array = new Constructor(length);

							    for (let i = 0; i < length; ++i) {
							      const val = (0, _lib.convertToNumber)(this[i]);
							      array[i] = callback.call(thisArg, val, i, _(this).proxy);
							    }

							    return array;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
							   */


							  filter(callback, ...opts) {
							    assertFloat16BitsArray(this);
							    const thisArg = opts[0];
							    const kept = [];

							    for (let i = 0, l = this.length; i < l; ++i) {
							      const val = (0, _lib.convertToNumber)(this[i]);

							      if (callback.call(thisArg, val, i, _(this).proxy)) {
							        kept.push(val);
							      }
							    }

							    const Constructor = (0, _spec.SpeciesConstructor)(this, Float16Array);
							    const array = new Constructor(kept);
							    return array;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
							   */


							  reduce(callback, ...opts) {
							    assertFloat16BitsArray(this);
							    const length = this.length;

							    if (length === 0 && opts.length === 0) {
							      throw TypeError("Reduce of empty array with no initial value");
							    }

							    let accumulator, start;

							    if (opts.length === 0) {
							      accumulator = (0, _lib.convertToNumber)(this[0]);
							      start = 1;
							    } else {
							      accumulator = opts[0];
							      start = 0;
							    }

							    for (let i = start; i < length; ++i) {
							      accumulator = callback(accumulator, (0, _lib.convertToNumber)(this[i]), i, _(this).proxy);
							    }

							    return accumulator;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
							   */


							  reduceRight(callback, ...opts) {
							    assertFloat16BitsArray(this);
							    const length = this.length;

							    if (length === 0 && opts.length === 0) {
							      throw TypeError("Reduce of empty array with no initial value");
							    }

							    let accumulator, start;

							    if (opts.length === 0) {
							      accumulator = (0, _lib.convertToNumber)(this[length - 1]);
							      start = length - 2;
							    } else {
							      accumulator = opts[0];
							      start = length - 1;
							    }

							    for (let i = start; i >= 0; --i) {
							      accumulator = callback(accumulator, (0, _lib.convertToNumber)(this[i]), i, _(this).proxy);
							    }

							    return accumulator;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
							   */


							  forEach(callback, ...opts) {
							    assertFloat16BitsArray(this);
							    const thisArg = opts[0];

							    for (let i = 0, l = this.length; i < l; ++i) {
							      callback.call(thisArg, (0, _lib.convertToNumber)(this[i]), i, _(this).proxy);
							    }
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
							   */


							  find(callback, ...opts) {
							    assertFloat16BitsArray(this);
							    const thisArg = opts[0];

							    for (let i = 0, l = this.length; i < l; ++i) {
							      const value = (0, _lib.convertToNumber)(this[i]);

							      if (callback.call(thisArg, value, i, _(this).proxy)) {
							        return value;
							      }
							    }
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
							   */


							  findIndex(callback, ...opts) {
							    assertFloat16BitsArray(this);
							    const thisArg = opts[0];

							    for (let i = 0, l = this.length; i < l; ++i) {
							      const value = (0, _lib.convertToNumber)(this[i]);

							      if (callback.call(thisArg, value, i, _(this).proxy)) {
							        return i;
							      }
							    }

							    return -1;
							  }
							  /**
							   * @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlast
							   */


							  findLast(callback, ...opts) {
							    assertFloat16BitsArray(this);
							    const thisArg = opts[0];

							    for (let i = this.length - 1; i >= 0; --i) {
							      const value = (0, _lib.convertToNumber)(this[i]);

							      if (callback.call(thisArg, value, i, _(this).proxy)) {
							        return value;
							      }
							    }
							  }
							  /**
							   * @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlastindex
							   */


							  findLastIndex(callback, ...opts) {
							    assertFloat16BitsArray(this);
							    const thisArg = opts[0];

							    for (let i = this.length - 1; i >= 0; --i) {
							      const value = (0, _lib.convertToNumber)(this[i]);

							      if (callback.call(thisArg, value, i, _(this).proxy)) {
							        return i;
							      }
							    }

							    return -1;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
							   */


							  every(callback, ...opts) {
							    assertFloat16BitsArray(this);
							    const thisArg = opts[0];

							    for (let i = 0, l = this.length; i < l; ++i) {
							      if (!callback.call(thisArg, (0, _lib.convertToNumber)(this[i]), i, _(this).proxy)) {
							        return false;
							      }
							    }

							    return true;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
							   */


							  some(callback, ...opts) {
							    assertFloat16BitsArray(this);
							    const thisArg = opts[0];

							    for (let i = 0, l = this.length; i < l; ++i) {
							      if (callback.call(thisArg, (0, _lib.convertToNumber)(this[i]), i, _(this).proxy)) {
							        return true;
							      }
							    }

							    return false;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
							   */


							  set(input, ...opts) {
							    assertFloat16BitsArray(this);
							    const targetOffset = (0, _spec.ToIntegerOrInfinity)(opts[0]);

							    if (targetOffset < 0) {
							      throw RangeError("offset is out of bounds");
							    } // for optimization


							    if (isFloat16Array(input)) {
							      // peel off Proxy
							      const float16bitsArray = getFloat16BitsArrayFromFloat16Array(input);
							      super.set(float16bitsArray, targetOffset);
							      return;
							    }

							    const targetLength = this.length;
							    const src = Object(input);
							    const srcLength = (0, _spec.LengthOfArrayLike)(src);

							    if (targetOffset === Infinity || srcLength + targetOffset > targetLength) {
							      throw RangeError("offset is out of bounds");
							    }

							    for (let i = 0; i < srcLength; ++i) {
							      this[i + targetOffset] = (0, _lib.roundToFloat16Bits)(src[i]);
							    }
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
							   */


							  reverse() {
							    assertFloat16BitsArray(this);
							    super.reverse();
							    return _(this).proxy;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
							   */


							  fill(value, ...opts) {
							    assertFloat16BitsArray(this);
							    super.fill((0, _lib.roundToFloat16Bits)(value), ...opts);
							    return _(this).proxy;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
							   */


							  copyWithin(target, start, ...opts) {
							    assertFloat16BitsArray(this);
							    super.copyWithin(target, start, ...opts);
							    return _(this).proxy;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
							   */


							  sort(...opts) {
							    assertFloat16BitsArray(this);
							    const compare = opts[0] !== undefined ? opts[0] : _spec.defaultCompare;
							    super.sort((x, y) => {
							      return compare((0, _lib.convertToNumber)(x), (0, _lib.convertToNumber)(y));
							    });
							    return _(this).proxy;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
							   */


							  slice(...opts) {
							    assertFloat16BitsArray(this);
							    const Constructor = (0, _spec.SpeciesConstructor)(this, Float16Array); // for optimization

							    if (Constructor === Float16Array) {
							      const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);
							      const float16bitsArray = uint16.slice(...opts);
							      return new Float16Array(float16bitsArray.buffer);
							    }

							    const length = this.length;
							    const start = (0, _spec.ToIntegerOrInfinity)(opts[0]);
							    const end = opts[1] === undefined ? length : (0, _spec.ToIntegerOrInfinity)(opts[1]);
							    let k;

							    if (start === -Infinity) {
							      k = 0;
							    } else if (start < 0) {
							      k = length + start > 0 ? length + start : 0;
							    } else {
							      k = length < start ? length : start;
							    }

							    let final;

							    if (end === -Infinity) {
							      final = 0;
							    } else if (end < 0) {
							      final = length + end > 0 ? length + end : 0;
							    } else {
							      final = length < end ? length : end;
							    }

							    const count = final - k > 0 ? final - k : 0;
							    const array = new Constructor(count);

							    if (count === 0) {
							      return array;
							    }

							    let n = 0;

							    while (k < final) {
							      array[n] = (0, _lib.convertToNumber)(this[k]);
							      ++k;
							      ++n;
							    }

							    return array;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
							   */


							  subarray(...opts) {
							    assertFloat16BitsArray(this);
							    const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);
							    const float16bitsArray = uint16.subarray(...opts);
							    const Constructor = (0, _spec.SpeciesConstructor)(this, Float16Array);
							    const array = new Constructor(float16bitsArray.buffer, float16bitsArray.byteOffset, float16bitsArray.length);
							    return array;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
							   */


							  indexOf(element, ...opts) {
							    assertFloat16BitsArray(this);
							    const length = this.length;
							    let from = (0, _spec.ToIntegerOrInfinity)(opts[0]);

							    if (from === Infinity) {
							      return -1;
							    }

							    if (from < 0) {
							      from += length;

							      if (from < 0) {
							        from = 0;
							      }
							    }

							    for (let i = from, l = length; i < l; ++i) {
							      if (hasOwnProperty.call(this, i) && (0, _lib.convertToNumber)(this[i]) === element) {
							        return i;
							      }
							    }

							    return -1;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
							   */


							  lastIndexOf(element, ...opts) {
							    assertFloat16BitsArray(this);
							    const length = this.length;
							    let from = opts.length >= 1 ? (0, _spec.ToIntegerOrInfinity)(opts[0]) : length - 1;

							    if (from === -Infinity) {
							      return -1;
							    }

							    if (from >= 0) {
							      from = from < length - 1 ? from : length - 1;
							    } else {
							      from += length;
							    }

							    for (let i = from; i >= 0; --i) {
							      if (hasOwnProperty.call(this, i) && (0, _lib.convertToNumber)(this[i]) === element) {
							        return i;
							      }
							    }

							    return -1;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
							   */


							  includes(element, ...opts) {
							    assertFloat16BitsArray(this);
							    const length = this.length;
							    let from = (0, _spec.ToIntegerOrInfinity)(opts[0]);

							    if (from === Infinity) {
							      return false;
							    }

							    if (from < 0) {
							      from += length;

							      if (from < 0) {
							        from = 0;
							      }
							    }

							    const isNaN = Number.isNaN(element);

							    for (let i = from, l = length; i < l; ++i) {
							      const value = (0, _lib.convertToNumber)(this[i]);

							      if (isNaN && Number.isNaN(value)) {
							        return true;
							      }

							      if (value === element) {
							        return true;
							      }
							    }

							    return false;
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
							   */


							  join(...opts) {
							    assertFloat16BitsArray(this);
							    const array = copyToArray(this);
							    return array.join(...opts);
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
							   */


							  toLocaleString(...opts) {
							    assertFloat16BitsArray(this);
							    const array = copyToArray(this);
							    return array.toLocaleString(...opts);
							  }
							  /**
							   * @see https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag
							   */


							  get [Symbol.toStringTag]() {
							    if (isFloat16BitsArray(this)) {
							      return "Float16Array";
							    }
							  }

							}
							/**
							 * @see https://tc39.es/ecma262/#sec-typedarray.bytes_per_element
							 */


							exports.Float16Array = Float16Array;
							Object.defineProperty(Float16Array, "BYTES_PER_ELEMENT", {
							  value: Uint16Array.BYTES_PER_ELEMENT
							});
							/**
							 * limitation: It is peaked by `Object.getOwnPropertySymbols(Float16Array)` and `Reflect.ownKeys(Float16Array)`
							 */

							Object.defineProperty(Float16Array, brand, {});
							const Float16ArrayPrototype = Float16Array.prototype;
							/**
							 * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
							 */

							Object.defineProperty(Float16ArrayPrototype, Symbol.iterator, {
							  value: Float16ArrayPrototype.values,
							  writable: true,
							  configurable: true
							});
							const defaultFloat16ArrayMethods = new WeakSet();

							for (const key of Reflect.ownKeys(Float16ArrayPrototype)) {
							  // constructor is not callable
							  if (key === "constructor") {
							    continue;
							  }

							  const val = Float16ArrayPrototype[key];

							  if (typeof val === "function") {
							    defaultFloat16ArrayMethods.add(val);
							  }
							}
						},
						"helper": {
							"arrayIterator.js": function (exports, module, require) {
								"use strict";

								Object.defineProperty(exports, "__esModule", {
								  value: true
								});
								exports.wrapInArrayIterator = wrapInArrayIterator;

								var _private = require("./private.js");

								const _ = (0, _private.createPrivateStorage)();

								const IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
								const ArrayIteratorPrototype = Object.create(IteratorPrototype, {
								  next: {
								    value: function next() {
								      return _(this).iterator.next();
								    },
								    writable: true,
								    configurable: true
								  },
								  [Symbol.toStringTag]: {
								    value: "Array Iterator",
								    configurable: true
								  }
								});
								/**
								 * @param {Iterator<number>} iterator
								 * @returns {IterableIterator<number>}
								 */

								function wrapInArrayIterator(iterator) {
								  const arrayIterator = Object.create(ArrayIteratorPrototype);
								  _(arrayIterator).iterator = iterator;
								  return arrayIterator;
								}
							},
							"is.js": function (exports, module, require) {
								"use strict";

								Object.defineProperty(exports, "__esModule", {
								  value: true
								});
								exports.isObject = isObject;
								exports.isObjectLike = isObjectLike;
								exports.isDataView = isDataView;
								exports.isTypedArray = isTypedArray;
								exports.isUint16Array = isUint16Array;
								exports.isArrayBuffer = isArrayBuffer;
								exports.isSharedArrayBuffer = isSharedArrayBuffer;
								exports.isIterable = isIterable;
								exports.isCanonicalIntegerIndexString = isCanonicalIntegerIndexString;

								var _spec = require("./spec.js");

								/**
								 * @param {unknown} value
								 * @returns {value is object}
								 */
								function isObject(value) {
								  return value !== null && typeof value === "object" || typeof value === "function";
								}
								/**
								 * @param {unknown} value
								 * @returns {value is object}
								 */


								function isObjectLike(value) {
								  return value !== null && typeof value === "object";
								}

								const toString = Object.prototype.toString;
								/**
								 * @param {unknown} value
								 * @returns {value is DataView}
								 */

								function isDataView(value) {
								  return ArrayBuffer.isView(value) && toString.call(value) === "[object DataView]";
								} // Inspired by util.types implementation of Node.js


								const TypedArrayPrototype = Object.getPrototypeOf(Uint8Array).prototype;
								const getTypedArrayPrototypeSybolToStringTag = Object.getOwnPropertyDescriptor(TypedArrayPrototype, Symbol.toStringTag).get;
								/**
								 * @param {unknown} value
								 * @returns {value is Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array}
								 */

								function isTypedArray(value) {
								  return getTypedArrayPrototypeSybolToStringTag.call(value) !== undefined;
								}
								/**
								 * @param {unknown} value
								 * @returns {value is Uint16Array}
								 */


								function isUint16Array(value) {
								  return getTypedArrayPrototypeSybolToStringTag.call(value) === "Uint16Array";
								}
								/**
								 * @param {unknown} value
								 * @returns {value is ArrayBuffer}
								 */


								function isArrayBuffer(value) {
								  return isObjectLike(value) && toString.call(value) === "[object ArrayBuffer]";
								}
								/**
								 * @param {unknown} value
								 * @returns {value is SharedArrayBuffer}
								 */


								function isSharedArrayBuffer(value) {
								  return isObjectLike(value) && toString.call(value) === "[object SharedArrayBuffer]";
								}
								/**
								 * @param {unknown} value
								 * @returns {value is Iterable}
								 */


								function isIterable(value) {
								  return isObject(value) && typeof value[Symbol.iterator] === "function";
								}
								/**
								 * @param {unknown} key
								 * @returns {value is string}
								 */


								function isCanonicalIntegerIndexString(key) {
								  return typeof key === "string" && key === (0, _spec.ToIntegerOrInfinity)(key) + "";
								}
							},
							"lib.js": function (exports, module, require) {
								"use strict";

								Object.defineProperty(exports, "__esModule", {
								  value: true
								});
								exports.roundToFloat16Bits = roundToFloat16Bits;
								exports.convertToNumber = convertToNumber;
								// algorithm: ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf
								const buffer = new ArrayBuffer(4);
								const floatView = new Float32Array(buffer);
								const uint32View = new Uint32Array(buffer);
								const baseTable = new Uint32Array(512);
								const shiftTable = new Uint32Array(512);

								for (let i = 0; i < 256; ++i) {
								  const e = i - 127; // very small number (0, -0)

								  if (e < -27) {
								    baseTable[i] = 0x0000;
								    baseTable[i | 0x100] = 0x8000;
								    shiftTable[i] = 24;
								    shiftTable[i | 0x100] = 24; // small number (denorm)
								  } else if (e < -14) {
								    baseTable[i] = 0x0400 >> -e - 14;
								    baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;
								    shiftTable[i] = -e - 1;
								    shiftTable[i | 0x100] = -e - 1; // normal number
								  } else if (e <= 15) {
								    baseTable[i] = e + 15 << 10;
								    baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
								    shiftTable[i] = 13;
								    shiftTable[i | 0x100] = 13; // large number (Infinity, -Infinity)
								  } else if (e < 128) {
								    baseTable[i] = 0x7c00;
								    baseTable[i | 0x100] = 0xfc00;
								    shiftTable[i] = 24;
								    shiftTable[i | 0x100] = 24; // stay (NaN, Infinity, -Infinity)
								  } else {
								    baseTable[i] = 0x7c00;
								    baseTable[i | 0x100] = 0xfc00;
								    shiftTable[i] = 13;
								    shiftTable[i | 0x100] = 13;
								  }
								}
								/**
								 * round a number to a half float number bits.
								 * @param {number} num - double float
								 * @returns {number} half float number bits
								 */


								function roundToFloat16Bits(num) {
								  floatView[0] = num;
								  const f = uint32View[0];
								  const e = f >> 23 & 0x1ff;
								  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);
								}

								const mantissaTable = new Uint32Array(2048);
								const exponentTable = new Uint32Array(64);
								const offsetTable = new Uint32Array(64);
								mantissaTable[0] = 0;

								for (let i = 1; i < 1024; ++i) {
								  let m = i << 13; // zero pad mantissa bits

								  let e = 0; // zero exponent
								  // normalized

								  while ((m & 0x00800000) === 0) {
								    e -= 0x00800000; // decrement exponent

								    m <<= 1;
								  }

								  m &= ~0x00800000; // clear leading 1 bit

								  e += 0x38800000; // adjust bias

								  mantissaTable[i] = m | e;
								}

								for (let i = 1024; i < 2048; ++i) {
								  mantissaTable[i] = 0x38000000 + (i - 1024 << 13);
								}

								exponentTable[0] = 0;

								for (let i = 1; i < 31; ++i) {
								  exponentTable[i] = i << 23;
								}

								exponentTable[31] = 0x47800000;
								exponentTable[32] = 0x80000000;

								for (let i = 33; i < 63; ++i) {
								  exponentTable[i] = 0x80000000 + (i - 32 << 23);
								}

								exponentTable[63] = 0xc7800000;
								offsetTable[0] = 0;

								for (let i = 1; i < 64; ++i) {
								  if (i === 32) {
								    offsetTable[i] = 0;
								  } else {
								    offsetTable[i] = 1024;
								  }
								}
								/**
								 * convert a half float number bits to a number.
								 * @param {number} float16bits - half float number bits
								 * @returns {number} double float
								 */


								function convertToNumber(float16bits) {
								  const m = float16bits >> 10;
								  uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 0x3ff)] + exponentTable[m];
								  return floatView[0];
								}
							},
							"private.js": function (exports, module, require) {
								"use strict";

								Object.defineProperty(exports, "__esModule", {
								  value: true
								});
								exports.createPrivateStorage = createPrivateStorage;

								/**
								 * @returns {(self:object) => object}
								 */
								function createPrivateStorage() {
								  const wm = new WeakMap();
								  return self => {
								    const storage = wm.get(self);

								    if (storage !== undefined) {
								      return storage;
								    }

								    const obj = Object.create(null);
								    wm.set(self, obj);
								    return obj;
								  };
								}
							},
							"spec.js": function (exports, module, require) {
								"use strict";

								Object.defineProperty(exports, "__esModule", {
								  value: true
								});
								exports.ToIntegerOrInfinity = ToIntegerOrInfinity;
								exports.LengthOfArrayLike = LengthOfArrayLike;
								exports.SpeciesConstructor = SpeciesConstructor;
								exports.defaultCompare = defaultCompare;

								/**
								 * @param {unknown} value
								 * @returns {value is object}
								 */
								function isObject(value) {
								  return value !== null && typeof value === "object" || typeof value === "function";
								}
								/**
								 * @param {unknown} target
								 * @returns {number}
								 */


								function ToIntegerOrInfinity(target) {
								  const number = Number(target);

								  if (Number.isNaN(number) || number === 0) {
								    return 0;
								  }

								  if (number === Infinity) {
								    return Infinity;
								  }

								  if (number === -Infinity) {
								    return -Infinity;
								  }

								  return Math.trunc(number);
								}
								/**
								 * @param {unknown} target
								 * @returns {number}
								 */


								function ToLength(target) {
								  const length = ToIntegerOrInfinity(target);

								  if (length < 0) {
								    return 0;
								  }

								  return length < Number.MAX_SAFE_INTEGER ? length : Number.MAX_SAFE_INTEGER;
								}
								/**
								 * @param {object} arrayLike
								 * @returns {number}
								 */


								function LengthOfArrayLike(arrayLike) {
								  if (!isObject(arrayLike)) {
								    throw TypeError("this is not a object");
								  }

								  return ToLength(arrayLike.length);
								}
								/**
								 * @param {object} target
								 * @param {Function} defaultConstructor
								 * @returns {Function}
								 */


								function SpeciesConstructor(target, defaultConstructor) {
								  if (!isObject(target)) {
								    throw TypeError("this is not a object");
								  }

								  const constructor = target.constructor;

								  if (constructor === undefined) {
								    return defaultConstructor;
								  }

								  if (!isObject(constructor)) {
								    throw TypeError("constructor is not a object");
								  }

								  const species = constructor[Symbol.species];

								  if (species == null) {
								    return defaultConstructor;
								  }

								  return species;
								}
								/**
								 * @param {number} x
								 * @param {number} y
								 * @returns {-1 | 0 | 1}
								 */


								function defaultCompare(x, y) {
								  const [isNaN_x, isNaN_y] = [Number.isNaN(x), Number.isNaN(y)];

								  if (isNaN_x && isNaN_y) {
								    return 0;
								  }

								  if (isNaN_x) {
								    return 1;
								  }

								  if (isNaN_y) {
								    return -1;
								  }

								  if (x < y) {
								    return -1;
								  }

								  if (x > y) {
								    return 1;
								  }

								  if (x === 0 && y === 0) {
								    const [isPlusZero_x, isPlusZero_y] = [Object.is(x, 0), Object.is(y, 0)];

								    if (!isPlusZero_x && isPlusZero_y) {
								      return -1;
								    }

								    if (isPlusZero_x && !isPlusZero_y) {
								      return 1;
								    }
								  }

								  return 0;
								}
							}
						},
						"hfround.js": function (exports, module, require) {
							"use strict";

							Object.defineProperty(exports, "__esModule", {
							  value: true
							});
							exports.hfround = hfround;

							var _lib = require("./helper/lib.js");

							/**
							 * returns the nearest half precision float representation of a number.
							 * @param {number} num
							 * @returns {number}
							 */
							function hfround(num) {
							  num = Number(num); // for optimization

							  if (!Number.isFinite(num) || num === 0) {
							    return num;
							  }

							  const x16 = (0, _lib.roundToFloat16Bits)(num);
							  return (0, _lib.convertToNumber)(x16);
							}
						}
					}
				}
			}
		},
		"src": {
			"bits.js": function (exports, module, require) {
				const ieee754 = require("./ieee754");
				const dom = require("./dom");

				const visualization = dom.$(".visualization-bits");
				const numberInput = dom.$("#number-input");
				const fpType = dom.$("#fp-type");


				const ftMap = {
				    fp16: {
				        expNormZero: -15,
				        expNormValue: 15,
				        expNormPosValue: 15,
				        expNormNegValue: -15,
				        dynksMin: -15,
				        dynksMax: 16,
				        exponentBits: 5,
				        significandBits: 10
				    },
				    fp32: {
				        expNormZero: -127,
				        expNormValue: 127,
				        expNormPosValue: 127,
				        expNormNegValue: -127,
				        dynksMin: -127,
				        dynksMax: 128,
				        exponentBits: 8,
				        significandBits: 23
				    },
				    fp64: {
				        expNormZero: -1023,
				        expNormValue: 1023,
				        expNormPosValue: 1023,
				        expNormNegValue: -1023,
				        dynksMin: -1023,
				        dynksMax: 1024,
				        exponentBits: 11,
				        significandBits: 52
				    }
				}

				function classNameFilter(className) {
				    return function (bit) {
				        return bit.classList.contains(className) && bit.classList.contains(fpType.value);
				    };
				}

				//
				// function keepVisibleBits(bits ){
				//     return bits.map(bit => bit.classList.contains(fpType.value) || [].slice.call(bit.classList).every(x => x !== "fp32" && x !== "fp64"));
				// }

				const bits = dom.$$(".bit", visualization);

				function bitsSign() {
				    return bits.filter(classNameFilter("sign"));
				}

				function bitsExponent() {
				    return bits.filter(classNameFilter("exponent"));
				}

				function bitsSignificand() {
				    return bits.filter(classNameFilter("significand"));
				}

				const pointSlider = dom.$("#point-slider");
				const pointSliderLabel = dom.$("#point-slider-label");

				function getInputNumberValue() {
				    return Number(numberInput.value.replace(/\u2212/g, "-"));
				}

				function setNumberInputValue(value) {
				    value = Number(value);
				    if (value === 0 && (1 / value < 0)) {
				        // special case to detect and show negative zero
				        value = "-0";
				    } else {
				        value = Number.prototype.toString.call(value);
				    }

				    value = value.replace(/-/g, "\u2212"); //pretty minus

				    if (value !== numberInput.value) {
				        numberInput.value = value;
				    }
				    updateVisualization();
				}


				function updateBitElementClasses( bitElements, bits, prevBit ) {
				    prevBit = typeof prevBit == "string" ? prevBit.slice(-1) : "0";
				    for (let i = 0; i < bits.length; i++) {
				        const bitElement = bitElements[i];
				        bitElement.classList.remove("one");
				        bitElement.classList.remove("zero");
				        bitElement.classList.remove("prev-one");
				        bitElement.classList.remove("prev-zero");

				        bitElement.classList.add(bits[i] === "1" ? "one" : "zero");
				        if (i === 0) {
				            bitElement.classList.add(prevBit === "1" ? "prev-one" : "prev-zero");
				        }
				    }
				}


				function updateBinary( parsed ) {
				    const isExpandedMode = visualization.classList.contains("expanded");
				    const bitsHidden = bits.filter(classNameFilter("hidden"));
				    updateBitElementClasses(bitsSign(), parsed.bSign);
				    updateBitElementClasses(bitsExponent(), parsed.bExponent, isExpandedMode ? "0" : parsed.bSign);
				    updateBitElementClasses(bitsHidden, parsed.bHidden);
				    updateBitElementClasses(bitsSignificand(), parsed.bSignificand, isExpandedMode ? parsed.bHidden : parsed.bExponent);

				    pointSliderLabel.style.left = (parsed.exponentNormalized - 1) * 15 + "px";

				    if (parsed.exponent !== Number(pointSlider.value)) {
				        pointSlider.value = parsed.exponent;
				    }
				}


				function classNamesToBinaryString( binaryString, bitSpan ) {
				    binaryString += bitSpan.classList.contains("zero") ? "0" : "1";
				    return binaryString;
				}

				function updateNumber( values ) {
				    let b = "";

				    let exponent, significand;
				    if (values) {
				        exponent = values.exponent;
				        // significand = values.significand;
				    }

				    if (typeof exponent == "number") {
				        exponent = ieee754.intToBinaryString(exponent, 11);
				    } else {
				        exponent = bitsExponent().reduce(classNamesToBinaryString, "");
				    }
				    if (typeof significand != "string") {
				        significand = bitsSignificand().reduce(classNamesToBinaryString, "");
				    }

				    b += bitsSign().reduce(classNamesToBinaryString, "");
				    b += exponent;
				    b += significand;

				    let f = ieee754.binaryStringToFloat(b, fpType.value);
				    setNumberInputValue(f);
				}


				function generatePowersHtml( b, startPower, classPrefix, useOne ) {
				    if (typeof startPower != "number") {
				        startPower = b.length - 1;
				    }

				    classPrefix = classPrefix || "exponent-bit-";

				    let htmlPowers = "";
				    let htmlComputed = "";
				    let htmlFractions = "";
				    let htmlFractionsComputed = "";

				    let allZeros = true;
				    for (let i = 0, l = b.length; i < l; i++) {
				        if (b[i] === "1") {
				            allZeros = false;
				            const p = startPower - i;
				            const j = b.length - 1 - i;
				            if (htmlPowers.length > 0) {
				                htmlPowers += "<span class='mo'> + </span>";
				                htmlComputed += "<span class='mo'> + </span>";
				                htmlFractions += "<span class='mo'> + </span>";
				                htmlFractionsComputed += "<span class='mo'> + </span>";
				            }

				            let powerHtml = '<span class="msup ' + (classPrefix + j) + '"><span class="mn">2</span><span class="mn">' + p + '</span></span>';

				            if (useOne && p === 0) {
				                powerHtml = '<span class="mn ' + (classPrefix + j) + '">1</span>';
				            }
				            htmlPowers += powerHtml;
				            htmlComputed += '<span class="mn ' + (classPrefix + j) + '">' + Math.pow(2, p) + '</span>';

				            if (p >= 0) {
				                htmlFractions += powerHtml;
				                htmlFractionsComputed += '<span class="mn ' + (classPrefix + j) + '">' + Math.pow(2, p) + '</span>';
				            } else {
				                htmlFractions += '<span class="mfrac ' + (classPrefix + j) + '"><span class="mn">1</span><span class="msup"><span class="mn">2</span><span class="mn">' + -p + '</span></span></span>';
				                htmlFractionsComputed += '<span class="mfrac ' + (classPrefix + j) + '"><span class="mn">1</span><span class="mn">' + Math.pow(2, -p) + '</span></span>';
				            }
				        }
				    }

				    if (allZeros) {
				        htmlPowers = htmlComputed = htmlFractions = htmlFractionsComputed = '<span class="mn">0</span>';
				    }

				    htmlFractionsComputed = htmlFractionsComputed.replace(/Infinity/g, "&infin;");

				    return {
				        powers: htmlPowers,
				        computed: htmlComputed,
				        fractions: htmlFractions,
				        fractionsComputed: htmlFractionsComputed
				    };
				}

				function updateMath( representation ) {
				    // enrich representation with powers HTML

				    const htmlExponent = generatePowersHtml(representation.bExponent);

				    representation.exponentPowers = htmlExponent.powers;
				    representation.exponentPowersComputed = htmlExponent.computed;

				    const significandBits = representation.bHidden + representation.bSignificand;

				    representation.exponentZero = representation.exponent;
				    representation.exponentNormalizedZero = representation.exponentNormalized;


				    // [...] subnormal numbers are encoded with a biased exponent of 0,
				    // but are interpreted with the value of the smallest allowed exponent,
				    // which is one greater (i.e., as if it were encoded as a 1).
				    //
				    // -- http://en.wikipedia.org/wiki/Denormal_number

				    if (representation.exponentNormalizedZero === ftMap[fpType.value].expNormZero) {
				        representation.exponentZero = representation.exponent + 1;
				        representation.exponentNormalizedZero = representation.exponentNormalized + 1;
				    }

				    const htmlSignificand = generatePowersHtml(significandBits, representation.exponentNormalizedZero, "significand-bit-");
				    const htmlSignificandNormalized = generatePowersHtml(significandBits, 0, "significand-bit-");
				    const htmlSignificandNormalizedOne = generatePowersHtml(significandBits, 0, "significand-bit-", true);

				    representation.significandPowersNormalized = htmlSignificandNormalized.powers;
				    representation.significandPowersNormalizedOne = htmlSignificandNormalizedOne.powers;

				    const equation = dom.$(".full-equation");

				    if (isNaN(representation.value)) {
				        representation.significandPowers = representation.significandPowersFractions
				            = representation.significandPowersFractionsComputed = representation.significandPowersComputed
				            = '<span class="mn significand-bit-any">NaN</span>';
				    } else {
				        representation.significandPowers = htmlSignificand.powers;
				        representation.significandPowersFractions = htmlSignificand.fractions;
				        representation.significandPowersFractionsComputed = htmlSignificand.fractionsComputed;
				        representation.significandPowersComputed = htmlSignificand.computed;
				    }

				    if (representation.sign < 0)
				        representation.signHtml = String(representation.sign).replace("-", "&minus;");
				    else
				        representation.signHtml = "+" + representation.sign;

				    representation.absValue = representation.raw_frac.s === 1 ? representation.value : representation.value.slice(1);

				    if (isNaN(representation.absValue)) {
				        representation.absValue = "NaNNaNNaNNaN Batman!"
				    }

				    representation.expNormPosValue = ftMap[fpType.value].expNormPosValue;
				    representation.expNormNegValue = ftMap[fpType.value].expNormNegValue;

				    dom.$$(".msum").forEach(elem => elem.setAttribute('data-to', ftMap[fpType.value].significandBits));
				    dom.$("#msub-text").innerHTML = ftMap[fpType.value].significandBits;

				    const value = representation.value;
				    representation.value = representation.frac;

				    const dynamic = dom.$$(".math [data-ieee754-value]");

				    dynamic.forEach(function (element) {
				        element.innerHTML = representation[element.dataset.ieee754Value];
				    });

				    if (isNaN(value) || !isFinite(value)) {
				        equation.classList.add("collapsed");
				    } else {
				        equation.classList.remove("collapsed");
				    }
				}

				function updateVisualization() {
				    const number = getInputNumberValue();
				    let representation = ieee754.toIEEE754Parsed(number, fpType.value);

				    updateBinary(representation);
				    updateMath(representation);
				}


				// EVENT HANDLERS

				fpType.addEventListener('change', function () {
				    dom.$$('.fp16').forEach(elem => elem.style.display = 'none');
				    dom.$$('.fp32').forEach(elem => elem.style.display = 'none');
				    dom.$$('.fp64').forEach(elem => elem.style.display = 'none');
				    dom.$$('.' + this.value).forEach(elem => elem.style = '');
				    updateVisualization();
				    updateNumber();
				});


				numberInput.addEventListener("change", function () {
				    setNumberInputValue(getInputNumberValue());
				    updateVisualization();
				    updateNumber();
				}, false);


				numberInput.addEventListener("keydown", function (event) {
				    let diff = 0;
				    if (event.keyCode === 38 || event.keyCode === 40) {

				        if (event.keyCode === 38) diff = +1;
				        else diff = -1;

				        if (event.shiftKey) {
				            diff *= 10;
				            if (event.altKey) {
				                diff *= 10;
				            }
				        } else if (event.altKey) {
				                diff /= 10;
				            }

				            setNumberInputValue( diff + getInputNumberValue() );

				        event.preventDefault();
				    }
				}, false);


				pointSlider.addEventListener( "change", function() {
				    const exponent = Number(pointSlider.value);
				    updateNumber( { exponent: exponent } );
				}, false);

				pointSlider.addEventListener( "click", function() {
				    pointSlider.focus();
				}, false);

				document.body.addEventListener( "click", function( event ){
				    const target = event.target;

				    if (target.classList.contains("zero") || target.classList.contains("one")) {
				        target.classList.toggle("zero");
				        target.classList.toggle("one");

				        updateNumber();
				        updateVisualization();

				        hoverRelatedExponentHandler( event );
				        hoverRelatedSignificandHandler( event );
				        hoverRelatedSignHandler( event );
				    }

				}, false);


				// toggle hover class on parts of equation related to hovered bit
				function createHoverRelatedHandler( selector, classPrefix ) {
				    return function (event) {
				        const target = event.target;
				        if (dom.matchesSelector( target, selector )) {

				            const siblings = dom.arrayify(target.parentNode.children).filter(classNameFilter("bit"));
				            const n = siblings.length - siblings.indexOf(target) - 1;

				            const related = dom.$$((classPrefix + n) + "," + (classPrefix + "any"));
				            related.forEach(function (r) {
				                r.classList[event.type === "mouseout" ? "remove" : "add"]("hover");
				            });
				        }
				    };
				}

				const hoverRelatedExponentHandler = createHoverRelatedHandler(".bit.exponent", ".exponent-bit-");
				document.body.addEventListener( "mouseover", hoverRelatedExponentHandler, false );
				document.body.addEventListener( "mouseout", hoverRelatedExponentHandler, false );

				const hoverRelatedSignificandHandler = createHoverRelatedHandler(".bit.significand, .bit.hidden", ".significand-bit-");
				document.body.addEventListener( "mouseover", hoverRelatedSignificandHandler, false );
				document.body.addEventListener( "mouseout", hoverRelatedSignificandHandler, false );

				const hoverRelatedSignHandler = createHoverRelatedHandler(".bit.sign", ".sign-bit-");
				document.body.addEventListener( "mouseover", hoverRelatedSignHandler, false );
				document.body.addEventListener( "mouseout", hoverRelatedSignHandler, false );


				// toggle nowrap class on a equation row when equals sign is clicked

				document.body.addEventListener( "click", function( event ){
				    const target = event.target;

				    if (dom.matchesSelector(target, ".mrow > .equals")) {
				        target.parentNode.classList.toggle("nowrap");
				    }

				}, false);


				// make exponent value editable

				const dynks = require("./dynks");

				const exponentElement = dom.$("#exponent-dynks");
				const exponentNormalizedElement = dom.$("#exponent-normalized-dynks");

				function getCurrentExponentValue() {
				    return +exponentElement.innerHTML;
				}

				function updateExponentValue(value) {
				    const exponent = Number(value);
				    updateNumber({exponent: exponent});
				}

				dynks(exponentElement, getCurrentExponentValue, updateExponentValue);

				function getCurrentExponentNormalizedValue() {
				    exponentNormalizedElement.dataset.dynksMin = ftMap[fpType.value].dynksMin;
				    exponentNormalizedElement.dataset.dynksMax = ftMap[fpType.value].dynksMax;
				    return +exponentNormalizedElement.innerHTML;
				}

				function updateExponentNormalizedValue(value) {
				    const exponent = Number(value);
				    updateNumber({exponent: exponent + ftMap[fpType.value].expNormValue});
				}
				dynks( exponentNormalizedElement, getCurrentExponentNormalizedValue, updateExponentNormalizedValue );


				dom.$(".toggle-details-button").addEventListener("click", function(){
				    visualization.classList.toggle("expanded");
				}, false);

				// GO!

				updateVisualization();
			},
			"dom.js": function (exports, module, require) {
				// `arraify` takes an array-like object and turns it into real Array
				// to make all the Array.prototype goodness available.
				const arrayify = function (a) {
				    return [].slice.call(a);
				};

				// `$` returns first element for given CSS `selector` in the `context` of
				// the given element or whole document.
				const $ = function (selector, context) {
				    context = context || document;
				    return context.querySelector(selector);
				};

				// `$$` return an array of elements for given CSS `selector` in the `context` of
				// the given element or whole document.
				const $$ = function (selector, context) {
				    context = context || document;
				    return arrayify(context.querySelectorAll(selector));
				};

				exports.arrayify = arrayify;
				exports.$ = $;
				exports.$$ = $$;


				// cross-browser matchesSelector based on
				// https://gist.github.com/jonathantneal/3062955
				const ElementPrototype = window.Element.prototype;

				const matchesSelector = ElementPrototype.matchesSelector ||
				    ElementPrototype.mozMatchesSelector ||
				    ElementPrototype.msMatchesSelector ||
				    ElementPrototype.oMatchesSelector ||
				    ElementPrototype.webkitMatchesSelector ||
				    function (selector) {
				        let node = this, nodes = (node.parentNode || node.document).querySelectorAll(selector), i = -1;

				        while (nodes[++i] && nodes[i] !== node) ;

				        return !!nodes[i];
				    };

				exports.matchesSelector = function( element, selector ) {
				    return matchesSelector.call( element, selector );
				}
			},
			"dynks.js": function (exports, module, require) {
				
				module.exports = function ( target, getCurrentValue, callback ) {

				    target.classList.add("dynks-enabled");

				    const options = {
				        gap: target.dataset.dynksGap || 5,
				        min: !isNaN(parseInt(target.dataset.dynksMin)) ? +target.dataset.dynksMin : -Infinity,
				        max: !isNaN(parseInt(target.dataset.dynksMax)) ? +target.dataset.dynksMax : +Infinity
				    };

				    target.addEventListener("mousedown", function (mouseDownEvent) {
				        const initialPosition = mouseDownEvent.pageX;
				        let lastValue = Number(getCurrentValue());
				        let lastSlot = 0;

				        function handleMouseMove(mouseMoveEvent) {
				            let currentSlot = (mouseMoveEvent.pageX - initialPosition) / options.gap;
				            currentSlot = ~~currentSlot;

				            const slotDiff = currentSlot - lastSlot;

				            if (slotDiff !== 0) {
				                let multiplier = 1;
				                if (mouseMoveEvent.shiftKey) multiplier = 10;

				                let currentValue = lastValue + slotDiff * multiplier;

				                if (currentValue < options.min) {
				                    currentValue = options.min;
				                    target.classList.add("dynks-out-of-range");
				                } else if (currentValue > options.max) {
				                    currentValue = options.max;
				                    target.classList.add("dynks-out-of-range");
				                } else {
				                    target.classList.remove("dynks-out-of-range");
				                }

				                callback( currentValue );

				                if (lastValue !== currentValue) {
				                    lastValue = currentValue;
				                    lastSlot = currentSlot;
				                }
				            }

				            mouseMoveEvent.preventDefault();
				        }

				        function handleMouseUp() {
				            target.classList.remove("dynks-active");
				            target.classList.remove("dynks-out-of-range");
				            document.documentElement.classList.remove("dynks-moving");
				            document.removeEventListener("mousemove", handleMouseMove, false );
				            document.removeEventListener("mouseup", handleMouseUp, false );
				        }

				        document.addEventListener( "mousemove", handleMouseMove, false );
				        document.addEventListener( "mouseup", handleMouseUp, false );

				        target.classList.add("dynks-active");
				        document.documentElement.classList.add("dynks-moving");

				        mouseDownEvent.preventDefault();
				    }, false );

				};
			},
			"ieee754.js": function (exports, module, require) {
				const {getFloat16, setFloat16} = require("../node_modules/@petamoriken/float16");
				const dom = require("./dom");
				const Fraction = require("fraction.js");

				// float16ToOctets( 123.456 ) -> [ 66, 246, 233, 121 ]
				function float16ToOctets(number) {
				    const buffer = new ArrayBuffer(2);
				    setFloat16(new DataView(buffer), 0, number, false);
				    return [].slice.call(new Uint8Array(buffer));
				}

				// octetsToFloat16( [ 66, 246, 233, 121 ] ) -> 123.456
				function octetsToFloat16(octets) {
				    const buffer = new ArrayBuffer(2);
				    new Uint8Array(buffer).set(octets);
				    return getFloat16(new DataView(buffer), 0, false);
				}

				// float32ToOctets( 123.456 ) -> [ 66, 246, 233, 121 ]
				function float32ToOctets(number) {
				    const buffer = new ArrayBuffer(4);
				    new DataView(buffer).setFloat32(0, number, false);
				    return [].slice.call(new Uint8Array(buffer));
				}

				// octetsToFloat32( [ 66, 246, 233, 121 ] ) -> 123.456
				function octetsToFloat32(octets) {
				    const buffer = new ArrayBuffer(4);
				    new Uint8Array(buffer).set(octets);
				    return new DataView(buffer).getFloat32(0, false);
				}

				// float64ToOctets( 123.456 ) -> [ 64, 94, 221, 47, 26, 159, 190, 119 ]
				function float64ToOctets(number) {
				    const buffer = new ArrayBuffer(8);
				    new DataView(buffer).setFloat64(0, number, false);
				    return [].slice.call(new Uint8Array(buffer));
				}

				// octetsToFloat64( [ 64, 94, 221, 47, 26, 159, 190, 119 ] ) -> 123.456
				function octetsToFloat64(octets) {
				    const buffer = new ArrayBuffer(8);
				    new Uint8Array(buffer).set(octets);
				    return new DataView(buffer).getFloat64(0, false);
				}

				// intToBinaryString( 8 ) -> "00001000"
				function intToBinaryString(i, length) {
				    length = length || 8;
				    for (i = i.toString(2); i.length < length; i = "0" + i) ;
				    return i;
				}

				// binaryStringToInt( "00001000" ) -> 8
				function binaryStringToInt(b) {
				    return parseInt(b, 2);
				}

				function octetsToBinaryString(octets) {
				    return octets.map(function (i) {
				        return intToBinaryString(i);
				    }).join("");
				}


				const fMap = {
				    fp16: {
				        eBits: 5,
				        sBits: 10,
				        eNorm: 15,
				        f2o: float16ToOctets,
				        o2f: octetsToFloat16
				    },
				    fp32: {
				        eBits: 8,
				        sBits: 23,
				        eNorm: 127,
				        f2o: float32ToOctets,
				        o2f: octetsToFloat32
				    },
				    fp64: {
				        eBits: 11,
				        sBits: 52,
				        eNorm: 1023,
				        f2o: float64ToOctets,
				        o2f: octetsToFloat64
				    }
				};

				function binaryStringToFloat(string, type) {
				    return fMap[type].o2f(string.match(/.{8}/g).map(binaryStringToInt));
				}

				function toIEEE754Parsed(v, fType) {
				    const string = octetsToBinaryString(fMap[fType].f2o(v));
				    const parts = string.match(new RegExp(`^(.)(.{${fMap[fType].eBits}})(.{${fMap[fType].sBits}})$`));
				    // sign{1} exponent{8/11} fraction{23/52}

				    const bSign = parts[1];
				    const sign = Math.pow(-1, parseInt(bSign, 2));

				    const bExponent = parts[2];
				    const exponent = parseInt(bExponent, 2);

				    const exponentNormalized = exponent - fMap[fType].eNorm;
				    const bSignificand = parts[3];

				    const bHidden = (exponent === 0) ? "0" : "1";
				    let exp2 = exponentNormalized;
				    if(exp2 === -fMap[fType].eNorm)
				        exp2 += 1;  // subnormal

				    const frac = dom
				        .arrayify(bSignificand)
				        .map((elem, i) => elem === "1" ? new Fraction(1, 2 ** (i + 1)) : null)  // significand
				        .filter(elem => elem !== null)
				        .reduce((prev, current) => prev.add(current), new Fraction(0))  // sum
				        .add(new Fraction(bHidden))  // hidden bit
				        .mul(new Fraction(2 ** exp2))
				        .mul(new Fraction(sign));

				    return {
				        raw_frac: frac,
				        frac: `${frac.toFraction()} &asymp; ${frac.toString()}`,
				        value: frac.toString(),
				        bFull: bSign + bExponent + bHidden + bSignificand,
				        bSign: bSign,
				        bExponent: bExponent,
				        bHidden: bHidden,
				        bSignificand: bSignificand,
				        sign: sign,
				        exponent: exponent,
				        exponentNormalized: exponentNormalized,
				    };
				}

				module.exports = {
				    intToBinaryString: intToBinaryString,
				    binaryStringToFloat: binaryStringToFloat,
				    toIEEE754Parsed: toIEEE754Parsed
				};
			}
		}
	}
})("ieee754-visualization/src/bits");
